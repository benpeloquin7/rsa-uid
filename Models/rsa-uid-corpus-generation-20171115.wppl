/**************************************************
/******************* Scaffolding *******************
***************************************************/
var runExperiment = function(speaker, world) {
  return sample(speaker(world))
}

var runExperiments = function(worldGenerator, speaker, n, data) {
  /*
  Parameters
  ----------
  worldGenerator: fn
    Generate a full world.
  spekeaker: fn
    RSA speaker function. Input worlds, output utterances.
  n: int
    Number of forward samples.
  data: array
    Data store (corpus).
    
  Returns
  -------
  array
    Array of utterances.
  
  */
  var world = worldGenerator()
  var currUtt = runExperiment(speaker, world)  // really this should be a dict object with context
  data.push(currUtt)
  return n <= 1 ? data : runExperiments(worldGenerator, speaker, n-1, data)
}

var worldGenerator = function() {
  /* Note that this is different from worldPrior. Ideally we will have more "complex"
  worlds of (a) multiple objects and (b) objects with multiple dimensions. In the 
  single object, single object case this will look just like a single prior over a dimension.
  */
  var colors = Categorical({
    vs:['r', 'b', 'g'], 
    ps:[1, 1, 1]})
  return {color: sample(colors)}
}

var THETA = 0.75
var worldDistr = Categorical({
  vs:[{color:'r'}, {color:'g'}, {color:'b'}], 
  ps:[0.1, 1, 1]
})
var worldPrior = function() {return sample(worldDistr)}
var utteranceDistr = Categorical({
  vs:['r', 'g', 'b', 'X r', 'X g', 'X b', 'X', ''], 
  ps:[1, 1, 1, 0.5, 0.5, 0.5, 0.01, 0.001]
})
var utterancePrior = function() {return sample(utteranceDistr)}

var decode = function(utteranceProduced, noiseModel) {
  Infer({
    model() {
      var utteranceIntended = utterancePrior()
      var noisyUtterance = noiseModel(utteranceIntended, THETA)
      factor(utteranceProduced == noisyUtterance ? 0 : -Infinity)
      return utteranceIntended
    }
  })
}


var buildSpeakerModel = function(listenerModel, utterancePrior, noiseModel) {
  /* Build generic speaker model.
  
  Parameters
  ----------
  listenerModel: fn
    Input world, output utterance.
  utterancePrior: fn
    Samples from prior over utterances.
  noiseModel: fn, optional
    Perturb utterance.
   
  Returns
  --------
  fn
    speaker function.

  */
  return function(world) {
    Infer({
      model() {
        var utterance = utterancePrior()
        if (noiseModel != undefined) {
          var noisyUtterance = noiseModel(utterance)
          var L = listenerModel(noisyUtterance)
          factor(L.score(world))
        } else {
          var L = listenerModel(utterance)
          factor(L.score(world))
        }
        return utterance
      }
    })
  }
}

var buildListenerModel = function(speakerModel, worldPrior, noiseModel) {
  /* Build generic listener model.
  
  Parameters
  ----------
  speakerModel: fn, optional
    Input world, output utterance.
  worldPrior : distr,
    Prior distribution over objects.
  noiseModel: fn, optional
    Invert noise model to reason about intended utterance from produced.
    E.g. p(u_intended | u_produced)
   
  Returns
  --------
  fn
    Listener function.

  */
  return function(utterance) {
    Infer({
      model(){
        var world = worldPrior()
        var S = speakerModel(world)
        if (noiseModel != undefined) {
          var intendedUtterance = sample(decode(utterance, noiseModel))
          factor(S.score(intendedUtterance))
        } else {
          factor(S.score(utterance))
        }
        return world
      }
    })
  }
}


/**************************************************
/******************* Run **************************
***************************************************/

/* To run experiment 
0. listener model.
  [REQUIRES] meaning fn
  [REQUIRES world prior
1. speaker model.
  [listener model] 
  [REQUIRES] utterance prior
2. world prior.
3. utterance prior.
4. data hold (array)

call run
*/

/* Noise models */
var _removeEmptyItems = function(arr) {
  filter(function(x) {return x != ''}, arr)
}

var replaceIndex = function(arr, index, replacement) {
  return arr.slice(0, index).concat([replacement]).concat(arr.slice(index + 1, arr.length))
}
var transformUtterance = function(transformFn) {
  return function(utterance) {
      var tokens = utterance.split(' ')
      var index = sample(RandomInteger({n:tokens.length}))
      var replacement = transformFn(index)
      return _removeEmptyItems(replaceIndex(tokens, index, replacement)).join(' ')
  }  
}
var _deleteFn = function(s) {
  return ''
}
var deleteTransform = transformUtterance(_deleteFn)

var vacuousNoiseModel = function(utterance) {
  return utterance
}
var deleteNoiseModel = function(utterance) {
  return flip(THETA) ? deleteTransform(utterance) : utterance
}

var utteranceMeaning = function(utterance) {
  var lastCharIndex = utterance.length - 1
  return utterance.includes('r') ? utterance.charAt(lastCharIndex) :
         utterance.includes('g') ? utterance.charAt(lastCharIndex) :
         utterance.includes('b') ? utterance.charAt(lastCharIndex) :
         sample(worldDistr)['color']
}

var meaning = function(utterance, world) {
  var worldColor = world['color']
  return utteranceMeaning(utterance) == worldColor
}

var buildListenerBase = function(noiseModel) {
  return function(utterance) {
    Infer({
      model() {
        var world = worldPrior()
        var intendedUtterance = sample(decode(utterance, noiseModel))
        var m = meaning(intendedUtterance, world)
        factor(m ? 0 : -Infinity)
        return world
      }
    })
  }
}

/**************************************************
/******************* Agents ***********************
***************************************************/

// var L0Base = function(utterance) {
//   Infer({
//     model() {
//       var world = worldPrior()
//       var utterance = utterance == '' ? utterancePrior() : utterance
//       var m = meaning(utterance, world)
//       factor(m ? 0 : -Infinity)
//       return world
//     }
//   })
// }

var L0Base = buildListenerBase(vacuousNoiseModel)
var L0Decoder = buildListenerBase(deleteNoiseModel)
var S1VV = buildSpeakerModel(L0Base, utterancePrior, vacuousNoiseModel)
var S1VD = buildSpeakerModel(L0Decoder, utterancePrior, vacuousNoiseModel)
var S1DV = buildSpeakerModel(L0Base, utterancePrior, deleteNoiseModel)
var S1DD = buildSpeakerModel(L0Decoder, utterancePrior, deleteNoiseModel)
var L1VVV = buildListenerModel(S1VV, worldPrior, vacuousNoiseModel)
var L1VVD = buildListenerModel(S1VD, worldPrior, vacuousNoiseModel)
var L1VDD = buildListenerModel(S1DD, worldPrior, vacuousNoiseModel)
var L1DDD = buildListenerModel(S1DD, worldPrior, deleteNoiseModel)
var L1DDV = buildListenerModel(S1DV, worldPrior, deleteNoiseModel)
var L1DVV = buildListenerModel(S1VV, worldPrior, deleteNoiseModel)
var L1DVD = buildListenerModel(S1VD, worldPrior, deleteNoiseModel)
var L1VDV = buildListenerModel(S1DV, worldPrior, vacuousNoiseModel)
var S2VVVV = buildSpeakerModel(L1VVV, utterancePrior, vacuousNoiseModel)
var S2VVVD = buildSpeakerModel(L1VVD, utterancePrior, vacuousNoiseModel)
var S2VVDD = buildSpeakerModel(L1VDD, utterancePrior, vacuousNoiseModel)
var S2VDDD = buildSpeakerModel(L1DDD, utterancePrior, vacuousNoiseModel)
var S2DDDD = buildSpeakerModel(L1DDD, utterancePrior, deleteNoiseModel)
var S2DDDV = buildSpeakerModel(L1DDV, utterancePrior, deleteNoiseModel)
var S2DDVV = buildSpeakerModel(L1DVV, utterancePrior, deleteNoiseModel)
var S2DVVV = buildSpeakerModel(L1VVV, utterancePrior, deleteNoiseModel) //
var S2DVVD = buildSpeakerModel(L1VVD, utterancePrior, deleteNoiseModel)
var S2VDDV = buildSpeakerModel(L1DDV, utterancePrior, vacuousNoiseModel)
var S2DVDV = buildSpeakerModel(L1VDV, utterancePrior, deleteNoiseModel)
var S2VVDV = buildSpeakerModel(L1VDV, utterancePrior, vacuousNoiseModel)
var S2VDVV = buildSpeakerModel(L1DVV, utterancePrior, vacuousNoiseModel)

// var d = []
// viz.table(runExperiments(worldGenerator, S1, 100, d))

// console.log('L0Base')
// viz.table(L0Base('X'))
// viz.table(L0Base('X r'))
// viz.table(L0Base('r'))
// console.log('L0Decoder')
// viz.table(L0Decoder('X'))
// viz.table(L0Decoder('X r'))
// viz.table(L0Decoder('r'))
// console.log('L1VVV')
// viz.table(L1VVV('X'))
// viz.table(L1VVV('X r'))
// viz.table(L1VVV('r'))
// console.log('L1VVD')
// viz.table(L1VVD('X'))
// viz.table(L1VVD('X r'))
// viz.table(L1VVD('r'))
// console.log('L1VDD')
// viz.table(L1VDD('X'))
// viz.table(L1VDD('X r'))
// viz.table(L1VDD('r'))
// console.log('L1DDD')
// viz.table(L1DDD('X'))
// viz.table(L1DDD('X r'))
// viz.table(L1DDD('r'))
console.log("Speakers")
console.log('S1VV')
viz.table(S1VV({color:'r'}))
viz.table(S1VV({color:'b'}))
console.log('S1VD')
viz.table(S1VD({color:'r'}))
viz.table(S1VD({color:'b'}))
console.log('S1DV')
viz.table(S1DV({color:'r'}))
viz.table(S1DV({color:'b'}))
console.log('S1DD')
viz.table(S1DD({color:'r'}))
viz.table(S1DD({color:'b'}))
console.log('S2VVVV')
viz.table(S2VVVV({color:'r'}))
viz.table(S2VVVV({color:'b'}))
console.log('S2VVVD')
viz.table(S2VVVD({color:'r'}))
viz.table(S2VVVD({color:'b'}))
console.log('S2VVDV')
viz.table(S2VVDV({color:'r'}))
viz.table(S2VVDV({color:'b'}))
console.log('S2VDVV')
viz.table(S2VDVV({color:'r'}))
viz.table(S2VDVV({color:'b'}))
console.log('S2DVVV')
viz.table(S2DVVV({color:'r'}))
viz.table(S2DVVV({color:'b'}))
console.log('S2VDDV')
viz.table(S2VDDV({color:'r'}))
viz.table(S2VDDV({color:'b'}))
console.log('S2VVDD')
viz.table(S2VVDD({color:'r'}))
viz.table(S2VVDD({color:'b'}))
console.log('S2VDDD')
viz.table(S2VDDD({color:'r'}))
viz.table(S2VDDD({color:'b'}))
console.log('S2DDDD')
viz.table(S2DDDD({color:'r'}))
viz.table(S2DDDD({color:'b'}))
console.log('S2DDDV')
viz.table(S2DDDV({color:'r'}))
viz.table(S2DDDV({color:'b'}))
console.log('S2DDVV')
viz.table(S2DDVV({color:'r'}))
viz.table(S2DDVV({color:'b'}))
console.log('S2DVVD')
viz.table(S2DVVD({color:'r'}))
viz.table(S2DVVD({color:'b'}))
console.log('S2DVDV')
viz.table(S2DVDV({color:'r'}))
viz.table(S2DVDV({color:'b'}))

