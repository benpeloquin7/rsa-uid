/**************************************************
/******************* Scaffolding *******************
***************************************************/
var runExperiment = function(speaker, world) {
  return sample(speaker(world))
}

var runExperiments = function(worldGenerator, speaker, n, data) {
  /*
  Parameters
  ----------
  worldGenerator: fn
    Generate a full world.
  spekeaker: fn
    RSA speaker function. Input worlds, output utterances.
  n: int
    Number of forward samples.
  data: array
    Data store (corpus).
    
  Returns
  -------
  array
    Array of utterances.
  
  */
  var world = worldGenerator()
  var currUtt = runExperiment(speaker, world)  // really this should be a dict object with context
  data.push(currUtt)
  return n <= 1 ? data : runExperiments(worldGenerator, speaker, n-1, data)
}

var worldGenerator = function() {
  /* Note that this is different from worldPrior. Ideally we will have more "complex"
  worlds of (a) multiple objects and (b) objects with multiple dimensions. In the 
  single object, single object case this will look just like a single prior over a dimension.
  */
  var colors = Categorical({vs:['r', 'b', 'g'], ps:[1, 1, 1]})
  return {color: sample(colors)}
}

var THETA = 0.2
var worldDistr = Categorical({vs:[{color:'r'}, {color:'g'}, {color:'b'}], ps:[0.1, 1, 1]})
var utteranceDistr = Categorical({vs:['r', 'g', 'b', 'X r', 'X g', 'X b', 'X'], ps:[1, 1, 1, 0.5, 0.5, 0.5, 0.01]})
var utterancePrior = function() {return sample(utteranceDistr)}
var worldPrior = function() {return sample(worldDistr)}

var decode = function(utteranceProduced, noiseModel) {
  Infer({
    model() {
      var utteranceIntended = utterancePrior()
      var noisyUtterance = noiseModel(utteranceIntended, THETA)
      factor(utteranceProduced == noisyUtterance ? 0 : -Infinity)
      return utteranceIntended
    }
  })
}


var buildSpeakerModel = function(listenerModel, utterancePrior, noiseModel) {
  /* Build generic speaker model.
  
  Parameters
  ----------
  listenerModel: fn
    Input world, output utterance.
  utterancePrior: fn
    Samples from prior over utterances.
  noiseModel: fn, optional
    Perturb utterance.
   
  Returns
  --------
  fn
    speaker function.

  */
  return function(world) {
    Infer({
      model() {
        var utterance = utterancePrior()
        if (noiseModel != undefined) {
          var noisyUtterance = noiseModel(utterance)
          var L = listenerModel(noisyUtterance)
          factor(L.score(world))
        } else {
          var L = listenerModel(utterance)
          factor(L.score(world))
        }
        return utterance
      }
    })
  }
}

var buildListenerModel = function(speakerModel, worldPrior, noiseModel) {
  /* Build generic listener model.
  
  Parameters
  ----------
  speakerModel: fn, optional
    Input world, output utterance.
  noiseModel: fn, optional
    Invert noise model to reason about intended utterance from produced.
    E.g. p(u_intended | u_produced)
   
  Returns
  --------
  fn
    Listener function.

  */
  return function(utterance) {
    Infer({
      model(){
        var world = worldPrior()
        var S = speakerModel(world)
        if (noiseModel != undefined) {
          var intendedUtterance = sample(decode(utterance, noiseModel))
          factor(S.score(intendedUtterance))
        } else {
          factor(S.score(utterance))
        }
        return world
      }
    })
  }
}


/**************************************************
/******************* Run **************************
***************************************************/

/* To run experiment 
0. listener model.
  [REQUIRES] meaning fn
  [REQUIRES world prior
1. speaker model.
  [listener model] 
  [REQUIRES] utterance prior
2. world prior.
3. utterance prior.
4. data hold (array)

call run
*/



/* Noise models */
var _removeEmptyItems = function(arr) {
  filter(function(x) {return x != ''}, arr)
}

var replaceIndex = function(arr, index, replacement) {
  return arr.slice(0, index).concat([replacement]).concat(arr.slice(index + 1, arr.length))
}
var transformUtterance = function(transformFn) {
  return function(utterance) {
      var tokens = utterance.split(' ')
      var index = sample(RandomInteger({n:tokens.length}))
      var replacement = transformFn(index)
      return _removeEmptyItems(replaceIndex(tokens, index, replacement)).join(' ')
  }  
}
var _deleteFn = function(s) {
  return ''
}
var deleteTransform = transformUtterance(_deleteFn)

var vacuousNoiseModel = function(utterance) {
  return utterance
}
var deleteNoiseModel = function(utterance) {
  return flip(THETA) ? deleteTransform(utterance) : utterance
}

var utteranceMeaning = function(utterance) {
  var lastCharIndex = utterance.length - 1
  return utterance.includes('r') ? utterance.charAt(lastCharIndex) :
         utterance.includes('g') ? utterance.charAt(lastCharIndex) :
         utterance.includes('b') ? utterance.charAt(lastCharIndex) :
         sample(worldDistr)['color']
}

var meaning = function(utterance, world) {
  var worldColor = world['color']
  return utteranceMeaning(utterance) == worldColor
}

var L0Base = function(utterance) {
  Infer({
    model() {
      var world = worldPrior()
      var utterance = utterance == '' ? utterancePrior() : utterance
      var m = meaning(utterance, world)
      factor(m ? 0 : -Infinity)
      return world
    }
  })
}

var buildListenerBaseWithDecoder = function(noiseModel) {
  return function(utterance) {
    Infer({
      model() {
        var world = worldPrior()
        var intendedUtterance = sample(decode(utterance, noiseModel))
        var m = meaning(intendedUtterance, world)
        factor(m ? 0 : -Infinity)
        return world
      }
    })
  }
}
var L0Decoder = buildListenerBaseWithDecoder(deleteNoiseModel)
var S1Base = buildSpeakerModel(L0Base, utterancePrior, vacuousNoiseModel)
var S1Decoder = buildSpeakerModel(L0Decoder, utterancePrior, deleteNoiseModel)
var L1Base = buildListenerModel(S1Base, worldPrior)
var L1Decoder = buildListenerModel(S1Decoder, worldPrior, vacuousNoiseModel)
var S2Base = buildSpeakerModel(L1Base, utterancePrior, vacuousNoiseModel)
var S2Decoder = buildSpeakerModel(L1Decoder, utterancePrior, vacuousNoiseModel)
var L2Base = buildListenerModel(S2Base, worldPrior)
var L2Decoder = buildListenerModel(S2Decoder, worldPrior, deleteNoiseModel)

// TODO -- explore this special agents some more

// Special speakers
var S2DecoderRecur = buildSpeakerModel(
  buildListenerModel(
    buildSpeakerModel(
      L0Decoder, utterancePrior, deleteNoiseModel), 
    worldPrior, deleteNoiseModel), 
  utterancePrior, deleteNoiseModel)

var S2DecoderBottom = buildSpeakerModel(
  buildListenerModel(
    buildSpeakerModel(
      L0Decoder, utterancePrior, deleteNoiseModel),
    worldPrior, vacuousNoiseModel),
  utterancePrior, vacuousNoiseModel)

// Special speakers
var L1DecoderRecur = buildListenerModel(
  buildSpeakerModel(
      L0Base, utterancePrior, deleteNoiseModel),
  worldPrior, vacuousNoiseModel)

var L1DecoderBottom = buildListenerModel(
  buildSpeakerModel(
      L0Base, utterancePrior, vacuousNoiseModel),
  worldPrior, vacuousNoiseModel)

var d = []
// viz.table(runExperiments(worldGenerator, S1, 100, d))

// console.log('L0Base')
// viz.table(L0Base('X'))
// console.log('L0Decoder')
// viz.table(L0Decoder('X')) // TODO (BP) get decoder working - see if that leads to 'X' as 'r' implicature
// console.log('L1Base')
// viz.table(L1Base('X'))
// console.log('L1Decoder')
// viz.table(L1Decoder('X'))
// console.log('L2Base')
// viz.table(L2Base('X'))
// console.log('L2Decoder')
// viz.table(L2Decoder('X'))

// console.log('S1Base')
// viz.table(S1Base({color:'r'}))
// viz.table(S1Base({color:'b'}))
// console.log('S1Decoder')
// viz.table(S1Decoder({color:'r'}))
// viz.table(S1Decoder({color:'b'}))
// console.log('S2Base')
// viz.table(S2Base({color:'r'}))
// viz.table(S2Base({color:'b'}))
// console.log('S2Decoder')
// viz.table(S2Decoder({color:'r'}))
// viz.table(S2Decoder({color:'b'}))

// console.log('S2Base')
// viz.table(S2Base({color:'r'}))
// viz.table(S2Base({color:'b'}))
// console.log('S2DecoderRecur')
// viz.table(S2DecoderRecur({color:'r'}))
// viz.table(S2DecoderRecur({color:'b'}))
// console.log('S2DecoderBottom')
// viz.table(S2DecoderBottom({color:'r'}))
// viz.table(S2DecoderBottom({color:'b'}))

console.log('L1Decoder')
viz.table(L1Base('r'))
viz.table(L1Base('X r'))
viz.table(L1Base('X'))
console.log('L1DecoderRecur')
viz.table(L1DecoderRecur('r'))
viz.table(L1DecoderRecur('X r'))
viz.table(L1DecoderRecur('X'))
console.log('L1DecoderBottom')
viz.table(L1DecoderBottom('r'))
viz.table(L1DecoderBottom('X r'))
viz.table(L1DecoderBottom('X'))

